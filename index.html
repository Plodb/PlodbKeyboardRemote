<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PlodbKeyboardRemote</title>
  <link rel="icon" href="data:image/png;base64,{ICON_BASE64}">
  <style>
    body {
      background: #fed7e9;
      margin: 0;
      font-family: monospace;
      justify-content: center;
      display: flex;
      width: 100vw;
      height: fit-content;
      overflow: hidden;
    }

    #keyboard {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 1rem;
      margin: 1rem;
      border-radius: 14px;
      background-color: white;
      height: fit-content;
      width: 100%;
    }

    .row {
      display: flex;
      gap: 6px;
    }

    button {
      flex: 1;
      padding: 6px 10px;
      font-size: 1.5vw;
      background: #fd9bca;
      color: #fff;
      border: #fc69b0 solid;
      border-radius: 5px;
      user-select: none;
      touch-action: manipulation;
      transition: all 0.1s ease;
    }

    button.spacebar {
      flex-grow: 6;
      flex-basis: 0;
    }

    button.pressed {
      background: #9bfdce !important;
      color: #111 !important;
      font-weight: bold;
      transform: scale(1.05);
    }

    button.held {
      background: #9bfdce !important;
      color: #111 !important;
      font-weight: bold;
      transform: scale(1.05);
    }
  </style>
</head>

<body>
  <button id="lang-switch" class="utility-button">üåê Lang</button>
  <div id="keyboard"></div>

  <script>
    let currentLayout = [];
    let currentLayoutName = "en";

    const container = document.getElementById("keyboard");
    let toggled = new Set();
    let timers = {};
    let lastClick = {};
    let holdTimeout = {};
    let tempHeld = new Set();

    const layout_en = [
      ["esc", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12"],
      ["`", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=", "backspace"],
      ["tab", "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]", "\\"],
      ["capslock", "a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'", "enter"],
      ["shift", "z", "x", "c", "v", "b", "n", "m", ",", ".", "/", "up", "?", "shift"],
      ["ctrl", "alt", "space", "alt", "ctrl", "left", "down", "right"]
    ];

    const layout_ru = [
      ["esc", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12"],
      ["—ë", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=", "backspace"],
      ["tab", "–π", "—Ü", "—É", "–∫", "–µ", "–Ω", "–≥", "—à", "—â", "–∑", "—Ö", "—ä", "\\"],
      ["capslock", "—Ñ", "—ã", "–≤", "–∞", "–ø", "—Ä", "–æ", "–ª", "–¥", "–∂", "—ç", "enter"],
      ["shift", "—è", "—á", "—Å", "–º", "–∏", "—Ç", "—å", "–±", "—é", ".", "up", "?", "shift"],
      ["ctrl", "alt", "space", "alt", "ctrl", "left", "down", "right"]
    ];

    const ruToEnMap = {
      "—ë": "`", "–π": "q", "—Ü": "w", "—É": "e", "–∫": "r", "–µ": "t", "–Ω": "y", "–≥": "u",
      "—à": "i", "—â": "o", "–∑": "p", "—Ö": "[", "—ä": "]", "—Ñ": "a", "—ã": "s", "–≤": "d",
      "–∞": "f", "–ø": "g", "—Ä": "h", "–æ": "j", "–ª": "k", "–¥": "l", "–∂": ";", "—ç": "'",
      "—è": "z", "—á": "x", "—Å": "c", "–º": "v", "–∏": "b", "—Ç": "n", "—å": "m",
      "–±": ",", "—é": ".", ".": "/"
    };

    const isModifier = key => ["ctrl", "shift", "alt"].includes(key);
    const isCommandKey = key => ["enter", "backspace", "delete", "tab"].includes(key);
    const toPhysical = key => currentLayoutName === "ru" && ruToEnMap[key] ? ruToEnMap[key] : key;

    function connectWS() {
      ws = new WebSocket("ws://" + location.hostname + ":8765");

      ws.onopen = () => {
        let pin = prompt("Enter PIN to connect:");
        if (pin) ws.send(JSON.stringify({ type: "pin", pin }));
      };

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);

        if (data.type === "pin_required") {
          alert("Wrong PIN or not authorized.");
        }

        if (data.type === "pin_accepted") {
          console.log("PIN accepted, full control granted.");
        }

        // existing handlers like sync, keyup, etc...
      };

      ws.onclose = () => {
        alert("WebSocket disconnected.");
      };
    }

    connectWS();

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.type === "sync") {
        currentLayoutName = data.layout;
        currentLayout = currentLayoutName === "ru" ? layout_ru : layout_en;
        renderKeyboard();
      }
      if (data.type === "keyup") {
        const key = data.key;
        toggled.delete(key);
        tempHeld.delete(key);
        const btn = document.querySelector(`button[data-key="${key}"]`);
        if (btn) btn.classList.remove("pressed", "held");
        updateHeld();
      }
    };

    function updateHeld() {
      document.querySelectorAll("button").forEach(btn => {
        const key = btn.dataset.key;

        if (key === "capslock") {
          const isCaps = navigator.getModifierState && navigator.getModifierState("CapsLock");
          btn.classList.toggle("held", isCaps);
        } else {
          btn.classList.toggle("held", toggled.has(key));
        }
      });
    }

    function renderKeyboard() {
      container.innerHTML = "";
      currentLayout.forEach(row => {
        const rowEl = document.createElement("div");
        rowEl.className = "row";

        row.forEach(key => {
          const btn = document.createElement("button");
          btn.innerText = key.length === 1 ? key.toUpperCase() : key;
          btn.dataset.key = key;
          btn.classList.add("key");

          if (key === "space") {
            btn.classList.add("spacebar");
            btn.innerText = "SPACE";
          }

          btn.onpointerdown = () => {
            const now = Date.now();
            const physicalKey = toPhysical(key);

            if (key === "capslock") {
              const shiftKey = "shift";
              const physicalShift = toPhysical(shiftKey);

              if (toggled.has(shiftKey)) {
                toggled.delete(shiftKey);
                ws.send(JSON.stringify({ type: "keyup", key: physicalShift }));
              } else {
                toggled.add(shiftKey);
                ws.send(JSON.stringify({ type: "keydown", key: physicalShift }));
              }

              updateHeld();
              return;
            }

            ["alt", "shift", "ctrl"].forEach(mod => {
              if (tempHeld.has(mod) && !toggled.has(mod) && key !== mod) {
                ws.send(JSON.stringify({ type: "keyup", key: toPhysical(mod) }));
                setTimeout(() => {
                  ws.send(JSON.stringify({ type: "keydown", key: toPhysical(mod) }));
                }, 25);
              }
            });

            clearTimeout(holdTimeout[key]);
            if (timers[key]) {
              clearInterval(timers[key]);
              delete timers[key];
            }

            if (isModifier(key)) {
              if (lastClick[key] && now - lastClick[key] < 300) {
                if (toggled.has(key)) {
                  toggled.delete(key);
                  ws.send(JSON.stringify({ type: "keyup", key: physicalKey }));
                } else {
                  toggled.add(key);
                  ws.send(JSON.stringify({ type: "keydown", key: physicalKey }));
                }
                updateHeld();
                return;
              }

              lastClick[key] = now;
              ws.send(JSON.stringify({ type: "keydown", key: physicalKey }));
              btn.classList.add("pressed");
              tempHeld.add(key);
              updateHeld();
              return;
            }

            if (isCommandKey(key)) {
              ws.send(JSON.stringify({ type: "keydown", key: physicalKey }));
              btn.classList.add("pressed");
              tempHeld.add(key);
              setTimeout(() => {
                if (tempHeld.has(key)) {
                  ws.send(JSON.stringify({ type: "keyup", key: physicalKey }));
                  tempHeld.delete(key);
                  btn.classList.remove("pressed");
                  updateHeld();
                }
              }, 2000);
              return;
            }

            tempHeld.add(key);
            holdTimeout[key] = setTimeout(() => {
              timers[key] = setInterval(() => {
                ws.send(JSON.stringify({ type: "keydown", key: physicalKey }));
              }, 50);
            }, 1500);

            ws.send(JSON.stringify({ type: "keydown", key: physicalKey }));
            btn.classList.add("pressed");

            setTimeout(() => {
              if (tempHeld.has(key)) {
                ws.send(JSON.stringify({ type: "keyup", key: physicalKey }));
                tempHeld.delete(key);
                btn.classList.remove("pressed");
                updateHeld();
              }
            }, 2000);
          };

          btn.onpointerup = () => {
            clearTimeout(holdTimeout[key]);
            if (timers[key]) {
              clearInterval(timers[key]);
              delete timers[key];
            }

            const physicalKey = toPhysical(key);

            if (key === "capslock") {
              toggled.delete(key);
              tempHeld.delete(key);
              btn.classList.remove("pressed", "held");
              updateHeld();
              return;
            }

            if (isModifier(key)) {
              if (tempHeld.has(key) && !toggled.has(key)) {
                ws.send(JSON.stringify({ type: "keyup", key: physicalKey }));
                tempHeld.delete(key);
                btn.classList.remove("pressed");
              }
              if (!toggled.has(key)) {
                btn.classList.remove("pressed");
              }
              updateHeld();
              return;
            }

            if (!toggled.has(key)) {
              ws.send(JSON.stringify({ type: "keyup", key: physicalKey }));
            }

            tempHeld.delete(key);
            btn.classList.remove("pressed");
            updateHeld();
          };

          btn.onpointerleave = () => {
            if (tempHeld.has(key) && !toggled.has(key)) {
              ws.send(JSON.stringify({ type: "keyup", key: toPhysical(key) }));
              tempHeld.delete(key);
              btn.classList.remove("pressed");
              updateHeld();
            }
          };

          rowEl.appendChild(btn);
        });
        container.appendChild(rowEl);
      });
      updateHeld();
    }

    window.addEventListener("blur", () => {
      for (const key of toggled) ws.send(JSON.stringify({ type: "keyup", key: toPhysical(key) }));
      for (const key of tempHeld) ws.send(JSON.stringify({ type: "keyup", key: toPhysical(key) }));
      toggled.clear();
      tempHeld.clear();
      updateHeld();
    });

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        for (const key of toggled) ws.send(JSON.stringify({ type: "keyup", key: toPhysical(key) }));
        for (const key of tempHeld) ws.send(JSON.stringify({ type: "keyup", key: toPhysical(key) }));
        toggled.clear();
        tempHeld.clear();
        updateHeld();
      }
    });

    document.getElementById("lang-switch").onclick = () => {
      const alt = "Alt", shift = "Shift";
      ws.send(JSON.stringify({ type: "keydown", key: alt }));
      setTimeout(() => ws.send(JSON.stringify({ type: "keydown", key: shift })), 100);
      setTimeout(() => ws.send(JSON.stringify({ type: "keyup", key: shift })), 150);
      setTimeout(() => ws.send(JSON.stringify({ type: "keyup", key: alt })), 200);
      setTimeout(() => ws.send(JSON.stringify({ type: "get_lang" })), 300);
    };

    currentLayout = layout_en;
    renderKeyboard();
    setInterval(() => {
      const capsBtn = document.querySelector('button[data-key="capslock"]');
      if (!capsBtn) return;

      const isCaps = navigator.getModifierState && navigator.getModifierState("CapsLock");
      if (isCaps) {
        capsBtn.classList.add("held");
      } else {
        capsBtn.classList.remove("held");
      }
    }, 500);
  </script>
</body>

</html>