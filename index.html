<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PlodbKeyboardRemote</title>
  <link rel="icon" href="data:image/png;base64,{ICON_BASE64}">
  <style>
    body {
      background: #fed7e9;
      margin: 0;
      font-family: monospace;
      justify-content: center;
      display: flex;
      width: 100vw;
      height: fit-content;
      overflow: hidden;
    }

    #keyboard {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 1rem;
      margin: 1rem;
      border-radius: 14px;
      background-color: white;
      height: fit-content;
      width: 100%;
    }

    .row {
      display: flex;
      gap: 6px;
    }

    button {
      flex: 1;
      padding: 6px 10px;
      font-size: 1.5vw;
      background: #fd9bca;
      color: #fff;
      border: #fc69b0 solid;
      border-radius: 5px;
      user-select: none;
      touch-action: manipulation;
      transition: all 0.1s ease;
    }

    button.spacebar {
      flex-grow: 6;
      flex-basis: 0;
    }



    button.held {
      background: #9bfdce !important;
      color: #111 !important;
      font-weight: bold;
      transform: scale(1.1);
    }
  </style>
</head>

<body>
  <div id="keyboard"></div>

  <script>
    const layout_en = [
      ["esc", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12"],
      ["`", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=", "backspace"],
      ["tab", "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]", "\\"],
      ["capslock", "a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'", "enter"],
      ["shift", "z", "x", "c", "v", "b", "n", "m", ",", ".", "/", "up", "?", "shift"],
      ["ctrl", "alt", "space", "alt", "ctrl", "left", "down", "right"]
    ];

    const layout_ru = [
      ["esc", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12"],
      ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=", "backspace"],
      ["tab", "й", "ц", "у", "к", "е", "н", "г", "ш", "щ", "з", "х", "ъ", "\\"],
      ["capslock", "ф", "ы", "в", "а", "п", "р", "о", "л", "д", "ж", "э", "enter"],
      ["shift", "я", "ч", "с", "м", "и", "т", "ь", "б", "ю", ".", "up", "?", "shift"],
      ["ctrl", "alt", "space", "alt", "ctrl", "left", "down", "right"]
    ];

    const ruToEnMap = {
      "1": "1", "2": "2", "3": "3", "4": "4", "5": "5", "6": "6", "7": "7", "8": "8", "9": "9", "0": "0", "-": "-", "=": "=",
      "й": "q", "ц": "w", "у": "e", "к": "r", "е": "t", "н": "y", "г": "u", "ш": "i", "щ": "o", "з": "p", "х": "[", "ъ": "]",
      "ф": "a", "ы": "s", "в": "d", "а": "f", "п": "g", "р": "h", "о": "j", "л": "k", "д": "l", "ж": ";", "э": "'",
      "я": "z", "ч": "x", "с": "c", "м": "v", "и": "b", "т": "n", "ь": "m", "б": ",", "ю": "."
    };

    let currentLayout = layout_en;
    const ws = new WebSocket("ws://" + location.hostname + ":8765");
    const container = document.getElementById("keyboard");
    let toggled = new Set();
    let timers = {};
    let lastClick = {};
    let holdTimeout = {};
    let tempHeld = new Set();

    const isModifier = key => ["ctrl", "shift", "alt"].includes(key);
    const isCommandKey = key => ["enter", "backspace", "delete", "tab"].includes(key);

    const renderKeyboard = () => {
      container.innerHTML = "";
      currentLayout.forEach(row => {
        const rowEl = document.createElement("div");
        rowEl.className = "row";
        row.forEach(key => {
          const btn = document.createElement("button");
          btn.innerText = key.length === 1 ? key.toUpperCase() : key;
          btn.dataset.key = key;
          btn.classList.add("key");

          if (key === "space") {
            btn.classList.add("spacebar");
            btn.innerText = "SPACE";
          }

          btn.onpointerdown = () => {
            const now = Date.now();
            let physicalKey = key;
            if (currentLayout === layout_ru && ruToEnMap[key]) {
              physicalKey = ruToEnMap[key];
            }

            if (isModifier(key)) {
              if (lastClick[key] && now - lastClick[key] < 300) {
                if (toggled.has(key)) {
                  toggled.delete(key);
                  ws.send(JSON.stringify({ type: "keyup", key: physicalKey }));
                } else {
                  toggled.add(key);
                  ws.send(JSON.stringify({ type: "keydown", key: physicalKey }));
                }
                updateHeld();
                return;
              }

              lastClick[key] = now;
              ws.send(JSON.stringify({ type: "keydown", key: physicalKey }));
              btn.classList.add("pressed");
              tempHeld.add(key);
              updateHeld();
              return;
            }

            if (isCommandKey(key)) {
              ws.send(JSON.stringify({ type: "keydown", key: physicalKey }));
              btn.classList.add("pressed");
              return;
            }

            holdTimeout[key] = setTimeout(() => {
              timers[key] = setInterval(() => {
                ws.send(JSON.stringify({ type: "keydown", key: physicalKey }));
              }, 50);
            }, 1500);

            ws.send(JSON.stringify({ type: "keydown", key: physicalKey }));
            btn.classList.add("pressed");

            setTimeout(() => {
              if (tempHeld.has(key)) {
                ws.send(JSON.stringify({ type: "keyup", key: physicalKey }));
                tempHeld.delete(key);
                btn.classList.remove("pressed");
                updateHeld();
              }
            }, 2000);
          };



          btn.onpointerup = () => {
            clearTimeout(holdTimeout[key]);
            if (typeof timers[key] === 'number') clearInterval(timers[key]);

            if (isModifier(key)) {
              if (tempHeld.has(key)) {
                ws.send(JSON.stringify({ type: "keyup", key }));
                tempHeld.delete(key);
                btn.classList.remove("pressed");
              }
              if (!toggled.has(key)) btn.classList.remove("pressed");
              updateHeld();
              return;
            }

            if (!toggled.has(key)) {
              let physicalKey = key;
              if (currentLayout === layout_ru && ruToEnMap[key]) {
                physicalKey = ruToEnMap[key];
              }
              ws.send(JSON.stringify({ type: "keyup", key: physicalKey }));
            }

            if (isCommandKey(key)) {
              ws.send(JSON.stringify({ type: "keyup", key }));
              btn.classList.remove("pressed");
            }
          };

          rowEl.appendChild(btn);
        });
        container.appendChild(rowEl);
      });
      updateHeld();
    };

    const updateHeld = () => {
      document.querySelectorAll("button").forEach(btn => {
        const key = btn.dataset.key;
        if (toggled.has(key)) {
          btn.classList.add("held");
        } else {
          btn.classList.remove("held");
        }
      });
    };

    window.addEventListener("blur", () => {
      for (const key of toggled) ws.send(JSON.stringify({ type: "keyup", key }));
      for (const key of tempHeld) ws.send(JSON.stringify({ type: "keyup", key }));
      toggled.clear();
      tempHeld.clear();
      updateHeld();
    });

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        for (const key of toggled) ws.send(JSON.stringify({ type: "keyup", key }));
        for (const key of tempHeld) ws.send(JSON.stringify({ type: "keyup", key }));
        toggled.clear();
        tempHeld.clear();
        updateHeld();
      }
    });

    const langSwitch = document.createElement("button");
    langSwitch.innerText = "RU / EN";
    langSwitch.style.position = "absolute";
    langSwitch.style.top = "8px";
    langSwitch.style.left = "8px";
    langSwitch.style.zIndex = "1000";
    langSwitch.onclick = () => {
      currentLayout = currentLayout === layout_en ? layout_ru : layout_en;
      renderKeyboard();
    };
    document.body.appendChild(langSwitch);

    renderKeyboard();
  </script>
</body>

</html>